import Expressions;
import OCLEvaluator;
import TupleAccessor;
import Sort;
import Util;
import Variables;
import VariableHelper;

modeltype allocationSpecification uses as('http://www.muml.org/psm/allocation/language/as/1.0.0');
modeltype ilptype uses ilp('http://www.muml.org/psm/allocation/ilp/1.0.0');
modeltype values uses values('http://www.eclipse.org/ocl/2015/Values');

-- XXX: we probably need a semantics change here generate ">= 1" inequalities
-- 		instead of "= 1" equations (needs to be discussed)
--		Since we now have relations, we need this even more!


library LocationConstraintLib;

helper Specification::createLocationConstraints(inout ilp : IntegerLinearProgram,
	oclContext : OclAny) {
	self.getLocationConstraints()->createLocationConstraint(ilp, oclContext);
}

helper LocationConstraint::createLocationConstraint(inout ilp : IntegerLinearProgram,
	oclContext : OclAny) {
	var groupedSequences : Sequence(Sequence(Sequence(OclAny))) := self.evaluateOCL(oclContext)
		.asTupleValueSequence()
		->collectNested(toSequence())
		->groupBySizeAndSort(); 
	groupedSequences->forEach(sequences) {
		sequences->forEach(seq) {
			seq->createHelperVariableAndConstraints(ilp);
		};
		while (sequences->notEmpty()) {
			var cur : Sequence(OclAny) := sequences->first();
			// since createConstraintExpression generates an equality ("= 1"),
			// we must get rid of duplicates (hence, we do the
			// -> OrderedSet -> Sequence conversion)
			// (actually, todo could be an OrderedSet(Sequence(OclAny)),
			// but the other helpers/queries expect a Sequence...)
			var todo : Sequence(Sequence(OclAny)) := cur->getAssociatedSequences(sequences)
				->asOrderedSet()->asSequence();
			sequences := sequences->reject(seq | todo->includes(seq));
			todo->createConstraintExpression(ilp, self)
		};
	};
}

query Sequence(Sequence(OclAny))::sortComponentResourceSequences() : Sequence(Sequence(OclAny)) {
	return self->collectNested(seq |
		seq->sortComponentResourceSequence()
	)->sortedBy(seq | seq->getVariableName());
}

query Sequence(Sequence(OclAny))::groupBySizeAndSort() : Sequence(Sequence(Sequence(OclAny))) {
	return self->collect(seq |
		seq->size()
	)->asSet()->sortedBy(seqSize : Integer |
		seqSize
	)->collectNested(seqSize : Integer |
		self->select(seq |
			seq->size() = seqSize
		)->sortComponentResourceSequences()
	)
}

query Sequence(OclAny)::getAssociatedSequences(sequence : Sequence(Sequence(OclAny)))
	: Sequence(Sequence(OclAny)) {
	return sequence->select(seq |
		let indexes : OrderedSet(Integer) = getOddNumbers(1, self->size())
		in
		indexes->collect(i |
			seq->at(i)
		)->asBag() = indexes->collect(i | self->at(i))->asBag()
	);
}

helper Sequence(Sequence(OclAny))::createConstraintExpression(inout ilp : IntegerLinearProgram,
	constraint : LocationConstraint) {
	var comment : String := if constraint.name <> '' then constraint.name else null endif;
	ilp.constraints += self->createAdditionConstraintExpression(
		Operator::EQUAL_TO, '1', comment
	);
}

query Specification::getLocationConstraints() : OrderedSet(LocationConstraint) {
	return self.constraints
		->select(oclIsKindOf(LocationConstraint))
		->collect(oclAsType(LocationConstraint))
		->asOrderedSet();
}
