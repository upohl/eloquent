package org.muml.psm.allocation.algorithm.ilp.tests.util;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.junit.Assert;
import org.muml.psm.allocation.ilp.ArithmeticExpression;
import org.muml.psm.allocation.ilp.BinaryExpression;
import org.muml.psm.allocation.ilp.ConstraintExpression;
import org.muml.psm.allocation.ilp.Expression;
import org.muml.psm.allocation.ilp.IntegerLinearProgram;
import org.muml.psm.allocation.ilp.LiteralExpression;
import org.muml.psm.allocation.ilp.Operator;
import org.muml.psm.allocation.ilp.Variable;
import org.muml.psm.allocation.ilp.VariableExpression;

/**
 * Can be used to compare ILPs (and expressions). Note that this only works for
 * ILPs that have a specific structure. Its main use case is to compare ILPs
 * that are generated by the Specification2ILP.qvto transformation (hence the
 * specific structure).
 * 
 * Big fat warning: this code is desperately looking for more love!
 */
public class FixedStructureILPComparator {
	private static final String unexpectedExpression = "unexpected expression: %s";
	private static final String DELIM = " ";
	
	public static void assertSameILP(IntegerLinearProgram expectedILP, IntegerLinearProgram actualILP) {
		Assert.assertNotNull(expectedILP);
		Assert.assertNotNull(actualILP);
		Assert.assertEquals(expectedILP.getVariables().size(),
				actualILP.getVariables().size());
		Assert.assertEquals(expectedILP.getConstraints().size(),
				actualILP.getConstraints().size());
		Set<String> expectedVariableNames = new HashSet<String>();
		for (Variable variable : expectedILP.getVariables()) {
			expectedVariableNames.add(variable.getName());
		}
		for (Variable variable : actualILP.getVariables()) {
			expectedVariableNames.remove(variable.getName());
		}
		// this is sufficient (we checked the sizes before)
		Assert.assertTrue(expectedVariableNames.isEmpty());
		assertSameExpressionLists(expectedILP.getConstraints(),
				actualILP.getConstraints());
		if (expectedILP.getObjectiveFunction() == null) {
			Assert.assertNull(actualILP.getObjectiveFunction());
		} else if (actualILP.getObjectiveFunction() == null) {
			Assert.assertNull(expectedILP.getObjectiveFunction());;
		} else {
			Assert.assertEquals(expectedILP.getObjectiveFunction().getGoal(),
					actualILP.getObjectiveFunction().getGoal());
			Assert.assertTrue(isReordering(expectedILP.getObjectiveFunction().getObjectiveFunction(),
					actualILP.getObjectiveFunction().getObjectiveFunction()));
		}
	}
	
	public static void assertSameExpressionLists(List<ConstraintExpression> expectedList, List<ConstraintExpression> actualList) {
		Assert.assertEquals(expectedList.size(), actualList.size());
		for (ConstraintExpression actualExpression : actualList) {
			Expression reorderedExpression = null;
			for (ConstraintExpression expectedExpression : expectedList) {
				// always recalculating the leaf ids is so stupid...
				if (isReordering(expectedExpression, actualExpression)) {
					reorderedExpression = expectedExpression;
					break;
				}
			}
			Assert.assertNotNull(reorderedExpression);
			expectedList.remove(reorderedExpression);
		}
	}
	
	public static boolean isReordering(ConstraintExpression expectedExpression,
			ConstraintExpression actualExpression) {
		if (expectedExpression.getOperator() != actualExpression.getOperator()) {
			return false;
		}
		boolean isReorder = isReordering(expectedExpression.getLeftExpression(),
				actualExpression.getLeftExpression());
		isReorder &= isReordering(expectedExpression.getRightExpression(),
				actualExpression.getRightExpression());
		return isReorder;
	}
	
	public static boolean isReordering(Expression expectedExpression, Expression actualExpression) {
		Map<String, Integer> expectedIdMap = getIds(expectedExpression);
		Map<String, Integer> actualIdMap = getIds(actualExpression);
		if (expectedIdMap.keySet().size() != actualIdMap.keySet().size()) {
			return false;
		}
		return expectedIdMap.equals(actualIdMap);
	}
	
	public static Map<String, Integer> getIds(Expression expression) {
		List<Expression> todo = new ArrayList<Expression>();
		todo.add(expression);
		Map<String, Integer> idMap = new HashMap<String, Integer>();
		while (!todo.isEmpty()) {
			expression = todo.remove(0);
			if (expression instanceof BinaryExpression) {
				BinaryExpression binaryExpression = (BinaryExpression) expression;
				Operator operator = binaryExpression.getOperator();
				if (operator == Operator.TIMES) {
					trackId(idMap, getLeafId(expression));
				} else if (operator != Operator.PLUS) {
					throw new IllegalArgumentException(
							String.format(unexpectedExpression, expression));
				} else {
					trackId(idMap, Operator.PLUS.getLiteral());
					todo.add(binaryExpression.getLeftExpression());
					todo.add(binaryExpression.getRightExpression());
				}
			} else {
				trackId(idMap, getLeafId(expression));
			}
		}
		return idMap;
	}
	
	public static void trackId(Map<String, Integer> idMap, String id) {
		Integer current = idMap.getOrDefault(id, 0);
		idMap.put(id, current + 1);
	}
	
	public static String getLeafId(Expression expression) {
		StringBuilder builder = new StringBuilder();
		if (expression instanceof ArithmeticExpression) {
			ArithmeticExpression arithmeticExpression =
					(ArithmeticExpression) expression;
			Operator operator = arithmeticExpression.getOperator();
			if (operator != Operator.TIMES) {
				throw new IllegalArgumentException(
						String.format(unexpectedExpression, expression));
			}
			builder.append(Operator.TIMES.getLiteral());
			builder.append(DELIM);
			// we assume a fixed structured here (if our expression does
			// not have this structure we fail with a CCE)
			builder.append(((LiteralExpression) arithmeticExpression.getLeftExpression())
					.getValue());
			builder.append(DELIM); 
			builder.append(((VariableExpression) arithmeticExpression.getRightExpression())
					.getVariable().getName());
		} else if (expression instanceof VariableExpression) {
			builder.append(((VariableExpression) expression)
					.getVariable().getName());
		} else if (expression instanceof LiteralExpression) {
			builder.append(((LiteralExpression) expression).getValue());
		} else {
			throw new IllegalArgumentException(
					String.format(unexpectedExpression, expression));
		}
		return builder.toString();
	}
}
